/////////////////////////////////////////////////////////////////////////////////
//~ [h] includes
#include "md.h"
#include "type_metadata.h"

#define PrintGenNoteCComment(f) fprintf((f), "// generated by %s:%d\n", __FILENAME__, __LINE__)
#undef MD_PrintGenNoteCComment
#define MD_PrintGenNoteCComment PrintGenNoteCComment

/////////////////////////////////////////////////////////////////////////////////
//~ globals
static MD_Arena *md_arena = 0;

FILE *error_file = 0;

GEN_TypeInfo *first_type = 0;
GEN_TypeInfo *last_type = 0;
MD_Map type_map = {0};

GEN_MapInfo *first_map = 0;
GEN_MapInfo *last_map = 0;
MD_Map map_map = {0};

#include <string.h>
#if defined(_WIN32)
# define __FILENAME__ (strrchr(__FILE__, '\\') ? strrchr(__FILE__, '\\') + 1 : __FILE__)
#else
# define __FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
#endif

#define EachTypeInfo(name, first) GEN_TypeInfo *name = first; name != 0; name = name->next

//~  //////////////////////////////////////////////////////////////////////

void
gen_type_default_initialisers(FILE *out)
{
    // @notes This Metadesk helper generates a comment that points back here.
    //  Generating a comment like this can help a lot to with issues later.
    PrintGenNoteCComment(out);
    
    for (GEN_TypeInfo *type = first_type;
         type != 0;
         type = type->next)
    {
        switch (type->kind)
        {
            default:break;
            
            case GEN_TypeKind_Struct:
            {
                if (MD_NodeHasTag(type->node, MD_S8Lit("default_init"), 0))
                {
                    MD_String8 struct_name = type->node->string;
                    fprintf(out, "#define %.*sMake(...) (%.*s){     \\\n", MD_S8VArg(struct_name), MD_S8VArg(struct_name));
                    
                    for (GEN_TypeMember *member = type->first_member;
                         member != 0;
                         member = member->next)
                    {
                        if (member->type->kind == GEN_TypeKind_Ext)
                        {
                            continue;
                        }
                        // gsp: Don't default init pointers or pointer arrays
                        if (MD_NodeHasTag(member->node, MD_S8Lit("ptr"), 0))
                        {
                            continue;
                        }
                        // gsp: Don't call default inits on nodes without them
                        if (!MD_NodeHasTag(member->node, MD_S8Lit("default_init"), 0))
                        {
                            continue;
                        }
                        
                        MD_String8 type_name = member->type->node->string;
                        MD_String8 member_name = member->node->string;
                        
                        MD_u32 repeatTimes = 1;
                        MD_b32 isArray = 0;
                        MD_Node *arrayTag = MD_TagFromString(member->node, MD_S8Lit("array"), 0);
                        if (!MD_NodeIsNil(arrayTag))
                        {
                            MD_Node   *tag_arg_node = arrayTag->first_child;
                            if (MD_StringIsCStyleInt(tag_arg_node->string))
                            {
                                repeatTimes = MD_CStyleIntFromString(tag_arg_node->string);
                            }
                            isArray = 1;
                            repeatTimes = repeatTimes <= 0 ? 1 : repeatTimes;
                        }
                        
                        for (MD_u32 it_x = 0; it_x < repeatTimes; ++it_x)
                        {
                            if (isArray)
                            {
                                fprintf(out, ".%.*s[%d] = ", MD_S8VArg(member_name), it_x);
                            }
                            else
                            {
                                fprintf(out, ".%.*s = ", MD_S8VArg(member_name));
                            }
                            
                            if (member->type->kind == GEN_TypeKind_Basic)
                            {
                                MD_Node *defValueTag =  MD_TagFromString(member->node, MD_S8Lit("defaultValue"), 0);
                                if (MD_NodeIsNil(defValueTag))
                                {
                                    defValueTag =  MD_TagFromString(member->type->node, MD_S8Lit("defaultValue"), 0);
                                }
                                if (!MD_NodeIsNil(defValueTag))
                                {
                                    MD_Node   *tag_arg_node = defValueTag->first_child;
                                    MD_String8 tag_arg_str = tag_arg_node->string;
                                    
                                    fprintf(out, "%.*s,            \\\n", MD_S8VArg(tag_arg_str));
                                }
                                else
                                {
                                    MD_CodeLoc loc = MD_CodeLocFromNode(member->node);
                                    MD_PrintMessage(error_file, loc, MD_MessageKind_Error,
                                                    MD_S8Lit("member nor type has default initialization"));
                                }
                            }
                            else if (member->type->kind == GEN_TypeKind_Struct)
                            {
                                fprintf(out, "%.*sMake(),            \\\n", MD_S8VArg(type_name));
                            }
                        }
                    }
                    
                    fprintf(out, "__VA_ARGS__ }\n\n");
                }
            }break;
            
            case GEN_TypeKind_ListType:
            {
                MD_String8 struct_name = type->node->string;
                
                //- wirte node
                fprintf(out, "typedef struct %.*s %.*s;\n", MD_S8VArg(struct_name), MD_S8VArg(struct_name));
                fprintf(out, "struct %.*s\n{\n", MD_S8VArg(struct_name));
                fprintf(out, "%.*s *next;\n", MD_S8VArg(struct_name));
                for (GEN_TypeMember *member = type->first_member;
                     member != 0;
                     member = member->next)
                {
                    MD_u32 ptrLevel = 0;
                    {
                        MD_Node *ptr_tag = MD_TagFromString(member->node, MD_S8Lit("ptr"), 0);
                        if (!MD_NodeIsNil(ptr_tag))
                        {
                            ptrLevel = MD_CStyleIntFromString(ptr_tag->string);
                        }
                    }
                    
                    
                    fprintf(out, ptrLevel > 0 ? 
                            "struct %.*s *%.*s;\n" : "%.*s %.*s;\n", MD_S8VArg(member->type->node->string), MD_S8VArg(member->node->string));
                }
                fprintf(out, "};\n\n");
                
                //- write list
                fprintf(out, "typedef struct %.*sList %.*sList;\n", -4 + MD_S8VArg(struct_name), -4 + MD_S8VArg(struct_name));
                fprintf(out, "struct %.*sList\n{\n", -4 + MD_S8VArg(struct_name));
                fprintf(out, "%.*s *first;\n", MD_S8VArg(struct_name));
                fprintf(out, "%.*s *last;\n", MD_S8VArg(struct_name));
                fprintf(out, "%.*s *free;\n", MD_S8VArg(struct_name));
                fprintf(out, "u32 nodeCount;\n");
                
                if (MD_NodeHasTag(type->node, MD_S8Lit("add_mutex"), 0))
                {
                    fprintf(out, "OS_Handle mutex;\n");
                }
                
                fprintf(out, "};\n\n");
            }
            
        }
    }
    
    fprintf(out, "\n");
}


//~ main //////////////////////////////////////////////////////////////////////

int
main(int argc, char **argv)
{
    // setup the global arena
    md_arena = MD_ArenaAlloc();
    
    // output stream routing
    error_file = stderr;
    
    // parse all files passed to the command line
    MD_Node *list = MD_MakeList(md_arena);
    for (int i = 1; i < argc; i += 1)
    {
        // parse the file
        MD_String8 file_name = MD_S8CString(argv[i]);
        MD_ParseResult parse_result = MD_ParseWholeFile(md_arena, file_name);
        
        // print metadesk errors
        for (MD_Message *message = parse_result.errors.first;
             message != 0;
             message = message->next)
        {
            MD_CodeLoc code_loc = MD_CodeLocFromNode(message->node);
            MD_PrintMessage(error_file, code_loc, message->kind, message->string);
        }
        
        // save to parse results list
        MD_PushNewReference(md_arena, list, parse_result.node);
    }
    
    // init maps
    type_map = MD_MapMake(md_arena);
    map_map = MD_MapMake(md_arena);
    
    // analysis phase
    gen_gather_types_and_maps(list);
    gen_check_duplicate_member_names();
    gen_equip_basic_type_size();
    gen_equip_struct_members();
    gen_equip_enum_underlying_type();
    gen_equip_enum_members();
    gen_equip_map_in_out_types();
    gen_equip_map_cases();
    gen_check_duplicate_cases();
    gen_check_complete_map_cases();
    
    // generate header file
    {
        FILE *h = fopen("code/render/vk/generated/vk_generated_types.h", "wb");
        fprintf(h, "#if !defined(META_TYPES_H)\n");
        fprintf(h, "#define META_TYPES_H\n\n\n");
        gen_type_definitions_from_types(h);
        gen_type_default_initialisers(h);
        fprintf(h, "\n\n\n\n/////////////////////////////////////////////////////////\n");
        fprintf(h, "//~ End of generated file\n");
        fprintf(h, "#endif // META_TYPES_H\n");
        fclose(h);
    }
    
    
#if 0
    // generate header file
    {
        FILE *h = fopen("meta_types.h", "wb");
        fprintf(h, "#if !defined(META_TYPES_H)\n");
        fprintf(h, "#define META_TYPES_H\n");
        gen_type_definitions_from_types(h);
        gen_function_declarations_from_maps(h);
        gen_type_info_declarations_from_types(h);
        fprintf(h, "#endif // META_TYPES_H\n");
        fclose(h);
    }
#endif
    
    // generate definitions file
#if 0
    {
        FILE *c = fopen("meta_types.c", "wb");
        gen_struct_member_tables_from_types(c);
        gen_enum_member_tables_from_types(c);
        gen_type_info_definitions_from_types(c);
        gen_function_definitions_from_maps(c);
        fclose(c);
    }
#endif
    
    
    // @notes The generated code doesn't go straight to stdout, and has a lot
    //  of transforms applied. When writing the analyzers, it's often useful to
    //  have a way to directly dump the results of analysis right to stdout to
    //  see what's going on.
    
    // print diagnostics of the parse analysis
#if 1
    for (GEN_TypeInfo *type = first_type;
         type != 0;
         type = type->next)
    {
        char *kind_string = "ERROR";
        switch (type->kind)
        {
            default:break;
            case GEN_TypeKind_Basic:  kind_string = "basic"; break;
            case GEN_TypeKind_Struct: kind_string = "struct"; break;
            case GEN_TypeKind_Enum:   kind_string = "enum"; break;
            case GEN_TypeKind_Ext:    kind_string = "ext"; break;
            case GEN_TypeKind_ListType:    kind_string = "list"; break;
        }
        
        MD_Node *node = type->node;
        printf("%.*s: %s\n", MD_S8VArg(node->string), kind_string);
        
        // print member lists
        for (GEN_TypeMember *member = type->first_member;
             member != 0;
             member = member->next)
        {
            printf("  %.*s: %.*s\n",
                   MD_S8VArg(member->node->string),
                   MD_S8VArg(member->type->node->string));
        }
        
        // print enumerant lists
        for (GEN_TypeEnumerant *enumerant = type->first_enumerant;
             enumerant != 0;
             enumerant = enumerant->next)
        {
            printf("  %.*s: %d\n",
                   MD_S8VArg(enumerant->node->string),
                   enumerant->value);
        }
    }
    
    for (GEN_MapInfo *map = first_map;
         map != 0;
         map = map->next)
    {
        MD_Node *node = map->node;
        printf("%.*s: map\n", MD_S8VArg(node->string));
        
        // print case list
        for (GEN_MapCase *map_case = map->first_case;
             map_case != 0;
             map_case = map_case->next)
        {
            printf("  %.*s -> %.*s\n",
                   MD_S8VArg(map_case->in_enumerant->node->string),
                   MD_S8VArg(map_case->out->string));
        }
    }
#endif
}

/////////////////////////////////////////////////////////////////////////////////
//~ [c] includes
#include "md.c"
#include "type_metadata.c"